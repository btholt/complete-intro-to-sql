{"pageProps":{"post":{"attributes":{},"html":"<blockquote>\n<p>This lesson uses the recipeguru database again. Use <code>\\c recipeguru</code> to get back to the recipeguru database.</p>\n</blockquote>\n<p>I know we&#39;ve been dealing with recipes which has a high tolerance for errors, particularly around making multiple inserts and updates in one query. It&#39;s not life threatening if we accidentally publish a recipe without a photo or an ingredient that isn&#39;t attached to a recipe. But fathom for a moment usecases where it is critical where you need to do multiple things at once and they all need to happen or zero need to happen.</p>\n<p>A good example of this would be bank accounts. If Bob is transferring $10,000 from his account to Alice&#39;s account, we need to subtract $10,000 from Bob&#39;s account and add $10,000 to Bob&#39;s. <strong>Both</strong> of those need to happen or <strong>neither</strong> of those needs to happen. We need it to be one <em>atomic</em> transaction. Atomic in this case means indivisible, or rather it needs to happen as if it was one single query. If Bob <em>just</em> loses $10,000 and Alice doesn&#39;t gain it the bank is committing theft and if Alice <em>just</em> gains $10,000 and Bob doesn&#39;t lose it then the bank is losing money by paying Alice. If neither happens, they may be a bit mad that it&#39;s taking a long time to get the transfer done but no damage has been done and we can try again.</p>\n<p>This is what transactions are for with PostgreSQL. It allows you to say &quot;hey, PostgreSQL, do all of these things and if anything fails or doesn&#39;t work, then do none of it. Let&#39;s give it a shot with the recipes database.</p>\n<p>You can really drive home how this works by opening a second terminal to the database and run a</p>\n<pre><code class=\"language-sql\">BEGIN;\n\nINSERT INTO ingredients (title, type) VALUES (&#39;whiskey&#39;, &#39;other&#39;);\nINSERT INTO ingredients (title, type) VALUES (&#39;simple syrup&#39;, &#39;other&#39;);\n\nINSERT INTO recipes (title, body) VALUES (&#39;old fashioned&#39;, &#39;mmmmmmm old fashioned&#39;);\n\nINSERT INTO recipe_ingredients\n  (recipe_id, ingredient_id)\nVALUES\n  (\n    (SELECT recipe_id FROM recipes where title=&#39;old fashioned&#39;),\n    (SELECT id FROM ingredients where title=&#39;whiskey&#39;)\n  ),\n  (\n    (SELECT recipe_id FROM recipes where title=&#39;old fashioned&#39;),\n    (SELECT id FROM ingredients where title=&#39;simple syrup&#39;)\n  );\n\nCOMMIT;\n</code></pre>\n<ul>\n<li><code>BEGIN</code> is how you <em>start</em> a transaction. You&#39;re telling PostgreSQL &quot;I&#39;m giving a few queries now, don&#39;t run them until I say <code>COMMIT</code> and then run <em>all</em> of them.</li>\n<li>If you <code>BEGIN</code> and decide you don&#39;t want to <code>COMMIT</code> you can run <code>ROLLBACK;</code> and it will not run any queries.</li>\n<li>If you want really prove a point to yourself, run the <code>BEGIN</code> and the first three <code>INSERT INTO</code> commands but don&#39;t run the last INSERT or the COMMIT. Open a second psql instance and try to query for &quot;whiskey&quot; in the ingredients table. You won&#39;t find it because we didn&#39;t <code>COMMIT</code> yet.</li>\n<li><code>BEGIN</code> is short for <code>BEGIN WORK</code> or <code>BEGIN TRANSACTION</code>. Any of those work.</li>\n</ul>\n<p>I used subqueries to get the IDs. You can use variables if you use plpgsql language and use <code>RETURNING INTO</code> and a variable name. Let&#39;s just show you what that could look like.</p>\n<pre><code class=\"language-sql\">BEGIN WORK;\n\nDO $$\nDECLARE champagne INTEGER;\nDECLARE orange_juice INTEGER;\nDECLARE mimosa INTEGER;\nBEGIN\n\nINSERT INTO ingredients (title, type) VALUES (&#39;champage&#39;, &#39;other&#39;) RETURNING id INTO champagne;\nINSERT INTO ingredients (title, type) VALUES (&#39;orange_juice&#39;, &#39;other&#39;) RETURNING id INTO orange_juice;\n\nINSERT INTO recipes (title, body) VALUES (&#39;mimosa&#39;, &#39;brunch anyone?&#39;) RETURNING recipe_id INTO mimosa;\n\nINSERT INTO recipe_ingredients\n  (recipe_id, ingredient_id)\nVALUES\n  (mimosa, champagne),\n  (mimosa, orange_juice);\n\nEND $$;\n\nCOMMIT WORK;\n</code></pre>\n<ul>\n<li>This is just to show you a different way to do it without subqueries. We&#39;re using the plpgpsql feature of variables. This does not work in normal SQL, we have to use the programming language.</li>\n<li>Notice the <code>BEGIN WORK</code> and <code>COMMIT WORK</code> are <strong>outside</strong> of the function. Postgres can&#39;t do transactions inside of functions. Other SQL databases can, just not Postgres.</li>\n<li>There&#39;s a <code>BEGIN WORK</code> for the transaction and a <code>BEGIN</code> for the function. They&#39;re different and do different things. I used <code>BEGIN WORK;</code> to make it very clear to you but you can use <code>BEGIN;</code> and it&#39;d work just fine.</li>\n</ul>\n","slug":"transactions","title":"Transactions","section":"Transactions","icon":"envelopes-bulk","filePath":"/home/runner/work/complete-intro-to-sql/complete-intro-to-sql/lessons/12-transactions/A-transactions.md","nextSlug":"/lessons/window-functions/window-functions","prevSlug":"/lessons/subqueries/arrays"}},"__N_SSG":true}