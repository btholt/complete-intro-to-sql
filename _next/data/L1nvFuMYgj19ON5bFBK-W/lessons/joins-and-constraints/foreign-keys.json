{"pageProps":{"post":{"attributes":{"description":""},"html":"<p>So far so good, we have the ability to query across tables and join them together. We have a problem though: what if we delete a recipe?</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">DELETE</span>\n<span class=\"hljs-keyword\">FROM</span>\n  recipes r\n<span class=\"hljs-keyword\">WHERE</span>\n  r.recipe_id <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">5</span>;\n<span class=\"hljs-comment\">-- The khachapuri</span>\n</code></pre>\n<p>Cool, we dropped the recipe, but what about the photos?</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">SELECT</span>\n  <span class=\"hljs-operator\">*</span>\n<span class=\"hljs-keyword\">FROM</span>\n  recipes_photos rp\n<span class=\"hljs-keyword\">WHERE</span>\n  rp.recipe_id <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">5</span>;\n</code></pre>\n<p>Oh no! Still there! Now, we could write a second query to drop these two, but it&#39;d be great if Postgres could track these changes for us and assure us they&#39;d never fall out of sync.</p>\n<p>Let&#39;s start with a fresh slate really quick.</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">DROP</span> <span class=\"hljs-keyword\">TABLE</span> IF <span class=\"hljs-keyword\">EXISTS</span> recipes;\n<span class=\"hljs-keyword\">DROP</span> <span class=\"hljs-keyword\">TABLE</span> IF <span class=\"hljs-keyword\">EXISTS</span> recipes_photos;\n<span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">TABLE</span> recipes (\n  recipe_id <span class=\"hljs-type\">INTEGER</span> <span class=\"hljs-keyword\">PRIMARY</span> KEY GENERATED ALWAYS <span class=\"hljs-keyword\">AS</span> <span class=\"hljs-keyword\">IDENTITY</span>,\n  title <span class=\"hljs-type\">VARCHAR</span> ( <span class=\"hljs-number\">255</span> ) <span class=\"hljs-keyword\">UNIQUE</span> <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span>,\n  body TEXT\n);\n<span class=\"hljs-keyword\">INSERT</span> <span class=\"hljs-keyword\">INTO</span> recipes\n  (title, body)\n<span class=\"hljs-keyword\">VALUES</span>\n  (<span class=\"hljs-string\">&#x27;cookies&#x27;</span>, <span class=\"hljs-string\">&#x27;very yummy&#x27;</span>),\n  (<span class=\"hljs-string\">&#x27;empanada&#x27;</span>,<span class=\"hljs-string\">&#x27;ugh so good&#x27;</span>),\n  (<span class=\"hljs-string\">&#x27;jollof rice&#x27;</span>, <span class=\"hljs-string\">&#x27;spectacular&#x27;</span>),\n  (<span class=\"hljs-string\">&#x27;shakshuka&#x27;</span>,<span class=\"hljs-string\">&#x27;absolutely wonderful&#x27;</span>),\n  (<span class=\"hljs-string\">&#x27;khachapuri&#x27;</span>, <span class=\"hljs-string\">&#x27;breakfast perfection&#x27;</span>),\n  (<span class=\"hljs-string\">&#x27;xiao long bao&#x27;</span>, <span class=\"hljs-string\">&#x27;god I want some dumplings right now&#x27;</span>);\n</code></pre>\n<p>Now, let&#39;s see what happens if we modify recipes_photos really quick.</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">TABLE</span> recipes_photos (\n  photo_id <span class=\"hljs-type\">INTEGER</span> <span class=\"hljs-keyword\">PRIMARY</span> KEY GENERATED ALWAYS <span class=\"hljs-keyword\">AS</span> <span class=\"hljs-keyword\">IDENTITY</span>,\n  url <span class=\"hljs-type\">VARCHAR</span>(<span class=\"hljs-number\">255</span>) <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span>,\n  recipe_id <span class=\"hljs-type\">INTEGER</span> <span class=\"hljs-keyword\">REFERENCES</span> recipes(recipe_id) <span class=\"hljs-keyword\">ON</span> <span class=\"hljs-keyword\">DELETE</span> CASCADE\n);\n</code></pre>\n<p>Okay, so we have a few things here</p>\n<ul>\n<li>The REFERENCES portion means it&#39;s going to be a foreign key. You tell it what it&#39;s going to match up to. In our case <code>recipes</code> is the table and <code>recipe_id</code> is the name of the column it&#39;ll match. In our case those are the same name, but it doesn&#39;t have to be. It must be the primary key of the other table.</li>\n<li>Then you need to tell it what to do when you delete something. With <code>ON DELETE CASCADE</code> you say &quot;if the row in the other table gets deleted, delete this one too.&quot; So if we delete something from recipes, it will automatically delete all its photos. Pretty cool, right?</li>\n<li>You can also do <code>ON DELETE SET NULL</code> which does exactly what it says it does. There&#39;s also <code>ON DELETE NO ACTION</code> which will error out if you try to delete something from recipes if there are still photos left. This forces developers to clean up photos before deleting recipes. That can be helpful to.</li>\n<li>There&#39;s also <code>ON UPDATE</code>s if you need to handle some synced state state between the two tables.</li>\n</ul>\n<p>If you&#39;re going to have have two tables reference each other, use foreign keys where possible. It makes useful constraints to make sure delete and update behaviors are intentional and it makes the queries faster.</p>\n","slug":"foreign-keys","title":"Foreign Keys","section":"Joins and Constraints","icon":"code-merge","filePath":"/home/runner/work/complete-intro-to-sql/complete-intro-to-sql/lessons/04-joins-and-constraints/C-foreign-keys.md","nextSlug":"/lessons/joins-and-constraints/many-to-many","prevSlug":"/lessons/joins-and-constraints/other-types-of-joins"}},"__N_SSG":true}