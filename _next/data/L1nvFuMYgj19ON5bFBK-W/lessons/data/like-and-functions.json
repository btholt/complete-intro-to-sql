{"pageProps":{"post":{"attributes":{"description":null},"html":"<p>Some times you want to search for something in your database but it&#39;s not an exact match. The best example would be if a user types something into the search bar, they&#39;re likely not giving you something that you match <em>exactly</em>. You would expect a search for &quot;pota&quot; to match &quot;potato&quot;, right? Enter <code>LIKE</code> in SQL.</p>\n<pre><code class=\"language-sql\">SELECT * FROM ingredients WHERE title LIKE &#39;%pota%&#39;;\n</code></pre>\n<p>This is a very limited fuzzy matching of text. This is not doing things like dropping &quot;stop words&quot; (like and, the, with, etc.) or handling plurals, or handling similar spellings (like color vs colour). Postgres <em>can</em> do this, and we&#39;ll get there later with indexes.</p>\n<h2 id=\"built-in-functions\">Built in functions</h2>\n<p>Okay, great, now what if a user searchs for &quot;fruit&quot;? We&#39;d expect that to work, right?</p>\n<pre><code class=\"language-sql\">SELECT * FROM ingredients WHERE CONCAT(title, type) LIKE &#39;%fruit%&#39;;\n</code></pre>\n<p><code>concat()</code> is a function that will take two strings and combine them together. We can concat our two title and type columns and then use LIKE on the results on that combined string.</p>\n<blockquote>\n<p>The result of the cherry row would be <code>cherryfruit</code> which means it&#39;d match weird strings like <code>rryfru</code>. We&#39;ll talk later about more complicated string matching but this will do for now.</p>\n</blockquote>\n<p>Okay, but what if we have capitalization problem? We can use lower, both on the columns and on the values.</p>\n<pre><code class=\"language-sql\">SELECT * FROM ingredients WHERE LOWER(CONCAT(title, type)) LIKE LOWER(&#39;%FrUiT%&#39;);\n</code></pre>\n<p><code>LOWER()</code> take a string and make it lowercase.</p>\n<p>Fortunately, there&#39;s an even easier way to do this with less function evocation.</p>\n<pre><code class=\"language-sql\">SELECT * FROM ingredients WHERE CONCAT(title, type) ILIKE &#39;%FrUiT%&#39;;\n</code></pre>\n<p><code>ILIKE</code> does the same thing, just with case insensitivity. Mostly I just wanted to show you lower!</p>\n<p>There are <em>so many</em> built in functions to Postgres. <a href=\"https://www.postgresql.org/docs/9.2/functions.html\">Click here to see the official docs.</a></p>\n<h2 id=\"-vs-_\">% vs _</h2>\n<p>You see that we&#39;ve been surrounding the <code>LIKE</code> values with <code>%</code>. This is basically saying &quot;match 0 to infinite characters&quot;. So with &quot;%berry&quot; you would match &quot;strawberry&quot; and &quot;blueberry&quot; but not &quot;berry ice cream&quot;. Because the &quot;%&quot; was only at the beginning it wouldn&#39;t match anything after, you&#39;d need &quot;%berry%&quot; to match both &quot;strawberry&quot; and &quot;blueberry ice cream&quot;.</p>\n<pre><code class=\"language-sql\">SELECT * FROM ingredients WHERE title ILIKE &#39;c%&#39;;\n</code></pre>\n<p>The above will give you all titles that start with &quot;c&quot;.</p>\n<p>You can put % anywhere. &quot;b%t&quot; will match &quot;bt&quot;, &quot;bot&quot;, &quot;but&quot;, &quot;belt&quot;, and &quot;belligerent&quot;.</p>\n<p>There also exists <code>_</code> which will match 1 and only one character. &quot;b_t&quot; will match &quot;bot&quot; and &quot;but&quot; but not &quot;bt&quot;, &quot;belt&quot;, or &quot;belligerent&quot;.</p>\n","slug":"like-and-functions","title":"Like and Functions","section":"Data","icon":"table","filePath":"/home/runner/work/complete-intro-to-sql/complete-intro-to-sql/lessons/03-data/D-like-and-functions.md","nextSlug":"/lessons/data/nodejs-and-postgresql","prevSlug":"/lessons/data/selects"}},"__N_SSG":true}