{"pageProps":{"post":{"attributes":{"description":""},"html":"<p>Let&#39;s next hop into SELECT, or how to read data from a database. We&#39;ve already seen the most basic one.</p>\n<pre><code class=\"language-sql\">SELECT * FROM ingredients;\n</code></pre>\n<p>The * there represents all available columns. Frequently, for a variety of reasons, we do not want to select everything. In general, I would recommend only using * where your intent is truly &quot;I want <em>anything this database could ever store for these records</em>&quot;. Frequently that is not the case. Frequently it is &quot;I need the name, address and email for this email, but not their social security or credit card number&quot;. This is positive because it means smaller transfer loads, that your system only processes data it needs and not the rest, and it shows intention in your code. Honestly the biggest benefit is the latter: to show intentions in your code.</p>\n<p>So in our case we could put</p>\n<pre><code class=\"language-sql\">SELECT id, title, image, type FROM ingredients;\n</code></pre>\n<p>When you read this now you know that the former coder was actively looking for those three columns.</p>\n<h2 id=\"limit-and-offset\">LIMIT and OFFSET</h2>\n<p>Okay, now what if the user only wants five records?</p>\n<pre><code class=\"language-sql\">SELECT id, title, image\nFROM ingredients\nLIMIT 5;\n</code></pre>\n<p>This will limit your return to only five records, the first five it finds. You frequently will need to do this as well (as in almost always) since a database can contain <em>millions</em> if not <em>billions</em> of records.</p>\n<p>So what if you want the next five records?</p>\n<pre><code class=\"language-sql\">SELECT id, title, image\nFROM ingredients\nLIMIT 5\nOFFSET 5;\n</code></pre>\n<p>This can be inefficient at large scales and without the use of indexes. It also has the problem of if you&#39;re paging through data and someone inserts a record in the meantime you could shift your results. We&#39;ll get into optimizing queries a bit later, but just be aware of that.</p>\n<p>In our exercise that is upcoming, feel free to use OFFSET.</p>\n<h2 id=\"where\">WHERE</h2>\n<p>Sometimes you don&#39;t want all of the records all at once. In that case you can add a WHERE clause where you tell the database to filter your results down to a subset of all of your records. What if we only wanted to show only fruits?</p>\n<pre><code class=\"language-sql\">SELECT *\nFROM ingredients\nWHERE type = &#39;fruit&#39;;\n</code></pre>\n<p>This will give us all the fruits we had. What if we wanted to only select vegetables where the the IDs are less 20?</p>\n<pre><code class=\"language-sql\">SELECT *\nFROM ingredients\nWHERE type = &#39;vegetable&#39;\n  AND id &lt; 20;\n</code></pre>\n<p>AND allows you to add multiple clauses to your selects. As you may guess, the presence of AND belies the existance of OR</p>\n<pre><code class=\"language-sql\">SELECT *\nFROM ingredients\nWHERE id &lt;= 10\n  OR id &gt;= 20;\n</code></pre>\n<h2 id=\"order-by\">ORDER BY</h2>\n<p>You frequently will care about the order these things come back in, how they&#39;re sorted. That&#39;s what ORDER BY is for.</p>\n<p>Let&#39;s say you wanted to order not by id or insertion order but by title.</p>\n<pre><code class=\"language-sql\">SELECT * FROM ingredients ORDER BY title;\n</code></pre>\n<p>This will alphabetize your returned list. What if we wanted it in reverse order of IDs?</p>\n<pre><code class=\"language-sql\">SELECT * FROM ingredients ORDER BY id DESC;\n</code></pre>\n<p>This will start at the largest number and count backwards. As you may have guessed, <code>ASC</code> is implied if you don&#39;t specify.</p>\n","slug":"selects","title":"Selects","section":"Data","icon":"table","filePath":"/home/runner/work/complete-intro-to-sql/complete-intro-to-sql/lessons/03-data/C-selects.md","nextSlug":"/lessons/data/like-and-functions","prevSlug":"/lessons/data/updates-and-deletes"}},"__N_SSG":true}