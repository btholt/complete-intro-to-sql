{"pageProps":{"post":{"attributes":{"description":""},"html":"<p>In the previous lesson we saw a way to make a partial index on the category_names table on only the English category names. What if we could make a mini-table of just those category names so we didn&#39;t have to add a <code>WHERE language=&#39;en&#39;</code> on every single query we do? This what views are: they&#39;re lens we can query through that we can treat as if they were just normal tables.</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">VIEW</span>\n  english_category_names\n<span class=\"hljs-keyword\">AS</span>\n<span class=\"hljs-keyword\">SELECT</span>\n  category_id, name, <span class=\"hljs-keyword\">language</span>\n<span class=\"hljs-keyword\">FROM</span>\n  category_names\n<span class=\"hljs-keyword\">WHERE</span>\n  <span class=\"hljs-keyword\">language</span><span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&#x27;en&#x27;</span>;\n</code></pre>\n<p>Now you can do:</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> english_category_names LIMIT <span class=\"hljs-number\">5</span>;\n</code></pre>\n<p>A few things to note here:</p>\n<ul>\n<li>We&#39;re querying this view as if it was a normal table. That&#39;s the power of views. You get to treat them as normal tables in your querying.</li>\n<li>Imagine you have a contractor working on your app with you but you don&#39;t want to give them access to everything in a table that they need to work on. You can make a view and give them only access to that one view. One of the powerful aspects of views.</li>\n<li>Views can utilized underlying indexes. You can&#39;t index a view itself but the data itself can be indexed.</li>\n</ul>\n<h2 id=\"inserting-into-views\">Inserting into views</h2>\n<p>Some pretty cool we can do here with <em>this</em> view (but not all views) is we can actually insert into the view itself. Because it&#39;s simple enough that if we insert a category_id and name with the language it&#39;ll be smart enough to forward that on to the correct table.</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">INSERT</span> <span class=\"hljs-keyword\">INTO</span> english_category_names (category_id, name, <span class=\"hljs-keyword\">language</span>) <span class=\"hljs-keyword\">VALUES</span> (<span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">&#x27;Brian Holt biopic&#x27;</span>, <span class=\"hljs-string\">&#x27;it&#x27;</span>);\n</code></pre>\n<blockquote>\n<p>Note that we inserted an Italian language even though it&#39;s an English table. It&#39;s going to enforce that only English works here.</p>\n</blockquote>\n<h2 id=\"views-with-joins\">Views with joins</h2>\n<p>This is cool to have a filtered view on a table, but let&#39;s make it even more compelling. A view can be more-or-less any SELECT query. So we can put joins together so instead of wild joins we can just query a view.</p>\n<p>Let&#39;s say you have a page on your app that you need to display actors &amp; actresses, the roles they played, and the movies those roles were in and this was a really common querying pattern for your app. Your query would look like:</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">SELECT</span>\n  p.name <span class=\"hljs-keyword\">AS</span> person_name, c.role, m.name <span class=\"hljs-keyword\">AS</span> movie_name, p.id <span class=\"hljs-keyword\">AS</span> person_id, m.id <span class=\"hljs-keyword\">AS</span> movie_id\n<span class=\"hljs-keyword\">FROM</span>\n  people p\n\n<span class=\"hljs-keyword\">INNER</span> <span class=\"hljs-keyword\">JOIN</span>\n  casts c\n<span class=\"hljs-keyword\">ON</span>\n  p.id <span class=\"hljs-operator\">=</span> c.person_id\n\n<span class=\"hljs-keyword\">INNER</span> <span class=\"hljs-keyword\">JOIN</span>\n  movies m\n<span class=\"hljs-keyword\">ON</span>\n  c.movie_id <span class=\"hljs-operator\">=</span> m.id\n\n<span class=\"hljs-keyword\">WHERE</span>\n  c.role <span class=\"hljs-operator\">&lt;&gt;</span> <span class=\"hljs-string\">&#x27;&#x27;</span>\nLIMIT <span class=\"hljs-number\">5</span>;\n</code></pre>\n<p>It&#39;s a bit of a mouthful from a quuerying perspective. So let&#39;s make it a view!</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">VIEW</span>\n  actors_roles_movies\n<span class=\"hljs-keyword\">AS</span>\n<span class=\"hljs-keyword\">SELECT</span>\n  p.name <span class=\"hljs-keyword\">AS</span> person_name, c.role, m.name <span class=\"hljs-keyword\">AS</span> movie_name, p.id <span class=\"hljs-keyword\">AS</span> person_id, m.id <span class=\"hljs-keyword\">AS</span> movie_id\n<span class=\"hljs-keyword\">FROM</span>\n  people p\n\n<span class=\"hljs-keyword\">INNER</span> <span class=\"hljs-keyword\">JOIN</span>\n  casts c\n<span class=\"hljs-keyword\">ON</span>\n  p.id <span class=\"hljs-operator\">=</span> c.person_id\n\n<span class=\"hljs-keyword\">INNER</span> <span class=\"hljs-keyword\">JOIN</span>\n  movies m\n<span class=\"hljs-keyword\">ON</span>\n  c.movie_id <span class=\"hljs-operator\">=</span> m.id\n\n<span class=\"hljs-keyword\">WHERE</span>\n  c.role <span class=\"hljs-operator\">&lt;&gt;</span> <span class=\"hljs-string\">&#x27;&#x27;</span>;\n</code></pre>\n<p>Now you can do</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> actors_roles_movies LIMIT <span class=\"hljs-number\">20</span>;\n</code></pre>\n<p>Much easier, right? And now we can do queries with this too! We can treat these views as if they were real tables when we do joins.</p>\n<p>What actors &amp; actresses tend to act in the same sorts of movies? We can know that by joining category names to movie keywords to movies to casts to people, right? Well, here we can make use of both of our views because we already have people to movies connected, and we have another view with just English category names already, so let&#39;s use both!</p>\n<blockquote>\n<p>This is a very expensive query (most expensive so far, I got <code>cost=293871.35..293871.40</code>.) If you have a slow computer, uncomment the WHERE clause.</p>\n</blockquote>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">SELECT</span>\n  arm.person_name, ecn.name <span class=\"hljs-keyword\">AS</span> keyword, <span class=\"hljs-built_in\">COUNT</span>(<span class=\"hljs-operator\">*</span>) <span class=\"hljs-keyword\">as</span> count\n<span class=\"hljs-keyword\">FROM</span>\n  actors_roles_movies arm\n\n<span class=\"hljs-keyword\">INNER</span> <span class=\"hljs-keyword\">JOIN</span>\n  movie_keywords mk\n<span class=\"hljs-keyword\">ON</span>\n  mk.movie_id <span class=\"hljs-operator\">=</span> arm.movie_id\n\n<span class=\"hljs-keyword\">INNER</span> <span class=\"hljs-keyword\">JOIN</span>\n  english_category_names ecn\n<span class=\"hljs-keyword\">ON</span>\n  ecn.category_id <span class=\"hljs-operator\">=</span> mk.category_id\n\n<span class=\"hljs-comment\">-- WHERE arm.person_name = &#x27;Julia Roberts&#x27;</span>\n\n<span class=\"hljs-keyword\">GROUP</span> <span class=\"hljs-keyword\">BY</span>\n  arm.person_name, ecn.name\n\n<span class=\"hljs-keyword\">ORDER</span> <span class=\"hljs-keyword\">BY</span>\n  count <span class=\"hljs-keyword\">DESC</span>\n\nLIMIT <span class=\"hljs-number\">20</span>;\n</code></pre>\n<p>This is the best part about views! We get the full power of PostgreSQL behind this summarized views that live-derive from our existing data.</p>\n","slug":"basic-views","title":"Basic Views","section":"Views","icon":"eye","filePath":"/home/runner/work/complete-intro-to-sql/complete-intro-to-sql/lessons/10-views/A-basic-views.md","nextSlug":"/lessons/views/materialized-views","prevSlug":"/lessons/query-performance/derivative-value-indexes"}},"__N_SSG":true}