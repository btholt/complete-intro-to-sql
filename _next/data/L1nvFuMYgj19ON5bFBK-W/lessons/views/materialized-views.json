{"pageProps":{"post":{"attributes":{"description":""},"html":"<p>In our last lesson we looked at views and then the final query we ran was <em>super expensive</em>. As in <code>cost=293871.35..293871.40</code> expensive. That&#39;s so expensive that we would not want to run that on every page load.</p>\n<p>So fathom this scenario. You show your boss this great query that shows how actors and actresses cluster around certain movie keywords and they want to ship a new page that shows users this in nice infographics. You think to yourself &quot;oh no, that&#39;s such an expensive query, we can&#39;t do that on every page if it&#39;s really popular page.&quot;</p>\n<p>So let&#39;s investigate the product problem</p>\n<ul>\n<li>You want to show users cool graphs with data from your database</li>\n<li>The query to get this data is expensive</li>\n<li>The data itself doesn&#39;t update too often. Only a few movies release per week and an actor/actress is only releasing a few movies a year</li>\n<li>This is a good place to use some sort of caching strategy</li>\n</ul>\n<p>So we could defintely use some sort of cache in front of the database. We could that manages setting a memcache or Redis cache of the response and then use that and then have some cron job that updates that cache every X hours or so.</p>\n<p>Or we could use what&#39;s called a materialized view. A materialized view is similar to a view but it&#39;s not live data. Instead you take a snapshot of what the query is now and then you query <em>that</em> data which is way cheaper. At that point it&#39;s just a normal table. You can even index it!</p>\n<p>Let&#39;s make a materialized view of our last query.</p>\n<pre><code class=\"language-sql\">CREATE MATERIALIZED VIEW\n  actor_categories\n\nAS\n\nSELECT\n  arm.person_name, ecn.name AS keyword, COUNT(*) as count\nFROM\n  actors_roles_movies arm\n\nINNER JOIN\n  movie_keywords mk\nON\n  mk.movie_id = arm.movie_id\n\nINNER JOIN\n  english_category_names ecn\nON\n  ecn.category_id = mk.category_id\n\nGROUP BY\n  arm.person_name, ecn.name\n\nWITH NO DATA;\n</code></pre>\n<ul>\n<li>We created the materialized view and provided it the query to get the data to populate itself.</li>\n<li>We specified to <em>not</em> yet populate it. Imagine if you were doing this on your production server. You want to be <em>very</em> judicious when you run this expensive query. If you leave out the <code>NO</code> part and say <code>WITH DATA</code> it&#39;ll run this query first time.</li>\n</ul>\n<p>Now if your try <code>SELECT * FROM actor_categories;</code> you&#39;ll get a &quot;not been populated&quot; error. So let&#39;s populate it!</p>\n<p>We have two options:</p>\n<ul>\n<li><code>REFRESH MATERIALIZED VIEW actor_categories;</code> - this goes faster but it locks the table so queries in the mean time won&#39;t work.</li>\n<li><code>REFRESH MATERIALIZED VIEW CONCURRENTLY actor_categories;</code> - this works far slower but doesn&#39;t lock the table in the process. Useful if you can&#39;t afford downtime on the view.</li>\n</ul>\n<p>Feel free to try both but I&#39;m going to do the first one.</p>\n<p>Amazing, now try</p>\n<pre><code class=\"language-sql\">SELECT * FROM actor_categories ORDER BY count DESC NULLS LAST LIMIT 10;\n</code></pre>\n<p><em>Much faster</em>. <code>EXPLAIN ANALYZE</code> gives us a cost of <code>cost=88408.08..88409.24</code> which is about 1/4 of the cost.</p>\n<blockquote>\n<p>Note the <code>NULLS LAST</code> is necessary or else <code>NULLS FIRST</code> is implicit and it won&#39;t use our index.</p>\n</blockquote>\n<p>The <code>NULLS LAST</code> portion isn&#39;t necessary here since nothing <em>should</em> be null but I wanted to show you this is how you&#39;d handle that.</p>\n<p>So, because this is an independent source of data, it can also be indexed! We can drive this cost <em>way</em> down on this query.</p>\n<pre><code class=\"language-sql\">CREATE INDEX idx_actor_categories_count ON actor_categories(count DESC NULLS LAST);\n</code></pre>\n<ul>\n<li>An index, you&#39;ve seen this before.</li>\n<li>We added a <code>DESC</code> to the index because primarily we&#39;ll be showing the thing with the <em>most</em> first. But keep in mind that PostgreSQL is perfectly capable of reading these indexes backwards so we can do ASC too on this same index.</li>\n<li>The <code>NULLS LAST</code> is wholly unnecessary but I wanted to throw it in there. Nothing in count should be null but if we did you can specify how you want it sorted.</li>\n</ul>\n<p>Okay, let&#39;s query it.</p>\n<pre><code class=\"language-sql\">EXPLAIN ANALYZE SELECT * FROM actor_categories ORDER BY count DESC NULLS LAST LIMIT 10;\n</code></pre>\n<p>A cost of <code>cost=0.43..0.75</code> as compared to the original cost of <code>cost=293871.35..293871.40</code>. Amazing. This is about a 40,000x increase in performance boost. Not too bad I&#39;d say!</p>\n","slug":"materialized-views","title":"Materialized Views","section":"Views","icon":"eye","filePath":"/home/runner/work/complete-intro-to-sql/complete-intro-to-sql/lessons/10-views/B-materialized-views.md","nextSlug":"/lessons/subqueries/how-to-subquery","prevSlug":"/lessons/views/basic-views"}},"__N_SSG":true}