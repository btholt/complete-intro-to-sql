{"pageProps":{"post":{"attributes":{},"html":"<p>You can also partially index tables. Let&#39;s take a look at category_names;</p>\n<pre><code class=\"language-sql\">\\d category_names\n\nSELECT * FROM category_names WHERE language = &#39;en&#39; LIMIT 5;\nSELECT COUNT(*) FROM category_names;\nSELECT DISTINCT language, COUNT(*) FROM category_names GROUP BY language;\n</code></pre>\n<p>We have a big table with 30,000+ rows but it has multiple different languages in the table. Let&#39;s say we&#39;re <em>mostly</em> querying just the English tags and don&#39;t need to refer to the other languages as much. Instead of indexing <em>everything</em> wastefully, we can do a partial index.</p>\n<pre><code class=\"language-sql\">CREATE INDEX idx_en_category_names ON category_names(language) WHERE language = &#39;en&#39;;\nEXPLAIN ANALYZE SELECT * FROM category_names WHERE language=&#39;en&#39; AND name ILIKE &#39;%animation%&#39; LIMIT 5;\nEXPLAIN ANALYZE SELECT * FROM category_names WHERE language=&#39;de&#39; AND name ILIKE &#39;%animation%&#39; LIMIT 5;\n</code></pre>\n<p>Not as much of a difference here as the table isn&#39;t <em>that</em> big and the overhead of the index is not helpful as it could be. Still, on my computer I see the <code>en</code> query&#39;s cost as <code>cost=133.69..643.89</code> and the <code>de</code> query&#39;s as <code>cost=0.00..833.55</code>. Still better!</p>\n","slug":"partial-indexes","title":"Partial Indexes","section":"Query Performance","icon":"fire","filePath":"/home/runner/work/complete-intro-to-sql/complete-intro-to-sql/lessons/09-query-performance/E-partial-indexes.md","nextSlug":"/lessons/query-performance/derivative-value-indexes","prevSlug":"/lessons/query-performance/gin"}},"__N_SSG":true}