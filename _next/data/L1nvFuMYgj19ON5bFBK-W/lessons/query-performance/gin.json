{"pageProps":{"post":{"attributes":{"title":"GIN"},"html":"<p>GIN stands for generalized inverted index. It&#39;s another data structure for indexes. In this case it&#39;s really useful for things where multiple values could apply to one row. A good example of this would be with JSONB columns: you have one column but it could have multiple values inside the object that a search could find. Fathom the below example:</p>\n<blockquote>\n<p>If you run these queries, you&#39;ll see it&#39;s still using sequential scan. You need pretty big tables (200+ rows? that&#39;s an estimate) for it to start being worth it to use your index.</p>\n</blockquote>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">TABLE</span> movie_reviews (\n  id <span class=\"hljs-type\">INTEGER</span> <span class=\"hljs-keyword\">PRIMARY</span> KEY GENERATED ALWAYS <span class=\"hljs-keyword\">AS</span> <span class=\"hljs-keyword\">IDENTITY</span>,\n  movie_id <span class=\"hljs-type\">INTEGER</span>,\n  scores JSONB <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span>\n);\n\n<span class=\"hljs-keyword\">INSERT</span> <span class=\"hljs-keyword\">INTO</span>\n  movie_reviews\n  (movie_id, scores)\n<span class=\"hljs-keyword\">VALUES</span>\n  (<span class=\"hljs-number\">21103</span>, <span class=\"hljs-string\">&#x27;{ &quot;rotten_tomatoes&quot;: 94, &quot;washington_post&quot;: 50, &quot;nytimes&quot;: 45 }&#x27;</span>),\n  (<span class=\"hljs-number\">97</span>, <span class=\"hljs-string\">&#x27;{ &quot;rotten_tomatoes&quot;: 87, &quot;washington_post&quot;: 40 }&#x27;</span>),\n  (<span class=\"hljs-number\">18235</span>, <span class=\"hljs-string\">&#x27;{ &quot;rolling_stone&quot;: 85, &quot;washington_post&quot;: 60, &quot;nytimes&quot;: 35 }&#x27;</span>),\n  (<span class=\"hljs-number\">10625</span>, <span class=\"hljs-string\">&#x27;{ &quot;rotten_tomatoes&quot;: 100, &quot;washington_post&quot;: 100, &quot;nytimes&quot;: 100, &quot;rolling_stone&quot;: 100 }&#x27;</span>),\n  (<span class=\"hljs-number\">85014</span>, <span class=\"hljs-string\">&#x27;{ &quot;nytimes&quot;: 67 }&#x27;</span>),\n  (<span class=\"hljs-number\">2493</span>, <span class=\"hljs-string\">&#x27;{ &quot;rotten_tomatoes&quot;: 67, &quot;rolling_stone&quot;: 89, &quot;nytimes&quot;: 85 }&#x27;</span>),\n  (<span class=\"hljs-number\">11362</span>, <span class=\"hljs-string\">&#x27;{ &quot;rotten_tomatoes&quot;: 76, &quot;washington_post&quot;: 14, &quot;nytimes&quot;: 98 }&#x27;</span>),\n  (<span class=\"hljs-number\">674</span>, <span class=\"hljs-string\">&#x27;{ &quot;rotten_tomatoes&quot;: 78, &quot;washington_post&quot;: 40, &quot;nytimes&quot;: 77, &quot;rolling_stone&quot;: 54 }&#x27;</span>);\n\n<span class=\"hljs-keyword\">CREATE</span> INDEX <span class=\"hljs-keyword\">ON</span> movie_reviews <span class=\"hljs-keyword\">USING</span> gin(scores);\nEXPLAIN ANALYZE <span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> movie_reviews <span class=\"hljs-keyword\">WHERE</span> scores ? <span class=\"hljs-string\">&#x27;rolling_stone&#x27;</span>;\nEXPLAIN ANALYZE <span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span>  <span class=\"hljs-keyword\">FROM</span> movie_reviews <span class=\"hljs-keyword\">WHERE</span> scores @<span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-string\">&#x27;{&quot;nytimes&quot;: 98}&#x27;</span>;\n</code></pre>\n<p>The above queries on a large table would be a great fit for a GIN index.</p>\n<h2 id=\"gin-and-full-text-search\">GIN and Full Text Search</h2>\n<p>GIN, like we said before, is good for things where you can have one column that have multiple values that can return true. So what if we took our search term (in this case let&#39;s search for <code>star wars</code>) and broke it down in smaller, searchable pieces? Like, three letter pieces, or as they&#39;re called, <em>trigrams</em>. This is one way PostgreSQL can handle full text search.</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">SELECT</span> SHOW_TRGM(<span class=\"hljs-string\">&#x27;star wars&#x27;</span>);\n</code></pre>\n<p>This shows you how PostgreSQL will break down star wars into multiple trigrams. It&#39;ll then search based on these and will use GIN to index these in the same fashioned it can index JSONB. Wild one technology works so well in two different ways.</p>\n<pre><code class=\"hljs language-sql\">EXPLAIN ANALYZE <span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> movies <span class=\"hljs-keyword\">WHERE</span> name ILIKE <span class=\"hljs-string\">&#x27;%star wars%&#x27;</span>;\n\n<span class=\"hljs-keyword\">CREATE</span> INDEX <span class=\"hljs-keyword\">ON</span> movies <span class=\"hljs-keyword\">USING</span> gin(name gin_trgm_ops);\n\nEXPLAIN ANALYZE <span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> movies <span class=\"hljs-keyword\">WHERE</span> name ILIKE <span class=\"hljs-string\">&#x27;%star wars%&#x27;</span>;\n</code></pre>\n<p>The <code>gin_trgm_ops</code> specifies the kind of indexing we want to do here and we&#39;re saying we want <code>trgm</code> or trigram operations. This is what you do for full text search.</p>\n<p>You should see a large difference between the two queries. My machine got <code>cost=0.00..4929.51</code> for the first query and <code>cost=28.13..88.65</code> for the second query.</p>\n<blockquote>\n<p>As you can see, using the index is nearly half the cost of the second query and which is why we&#39;d need a pretty big data set for the JSONB query to use the index.</p>\n</blockquote>\n","slug":"gin","title":"GIN","section":"Query Performance","icon":"fire","filePath":"/home/runner/work/complete-intro-to-sql/complete-intro-to-sql/lessons/09-query-performance/D-gin.md","nextSlug":"/lessons/query-performance/partial-indexes","prevSlug":"/lessons/query-performance/create-an-index"}},"__N_SSG":true}