{"pageProps":{"post":{"attributes":{},"html":"<h2 id=\"identifying-what-to-index\">Identifying what to index</h2>\n<p>We&#39;ve identified some slow queries and how to diagnose them as slow. We&#39;ve identified what a index scan is versus what a sequential scan is. Here we&#39;re going to learn how to index things and when we want to do that.</p>\n<p>First thing is, <em>don&#39;t index everything</em>. Indexes take space and do incur some overhead for PostgreSQL to decide if it&#39;s going to use (using what&#39;s called the query planner.) If you have data that&#39;s rarely accessed or frequently filtered out then don&#39;t index it!</p>\n<p>So what do you index? Things you query frequently that have to filter out lots of rows.</p>\n<h2 id=\"its-okay-that-sometimes-that-the-planner-doesnt-use-the-index\">It&#39;s okay that sometimes that the planner doesn&#39;t use the index</h2>\n<p>Another thing to keep in mind is indexes are only useful when you&#39;re filtering data out or doing some sort of different sort. It all depends on what you want to do.</p>\n<p>Think of it like a dictionary and the page numbers are like indexes you can query on. If you&#39;re looking for one word, &#39;defenestrate&#39;, it&#39;s easy to use the page numbers / index to look up that one query quickly. You don&#39;t have to scan every row / word on the As-Cs to find the word: you can skip until you&#39;re close.</p>\n<p>However what if your goal is to read the dictionary cover to cover? What use are indexes are you for then? You wouldn&#39;t use the page numbers at all in this case (and neither would the planner.) Therefore the planner would still use sequential scan because adding an index just adds unnecessary overhead.</p>\n<p>This isn&#39;t just for complete datasets either. Imagine you&#39;re reading the whole dataset <em>except</em> the Xs. The X section is so short you&#39;d probably just scan over them to get to the Ys. Same thing with the planner: it&#39;ll make a call sometimes to just scan over rows because adding an index would be too much overhead. Basically what I&#39;m saying is that the planner is usually right even if it&#39;s unintuitive.</p>\n<h2 id=\"unique-indexes\">Unique indexes</h2>\n<p>So we&#39;ve seen and used one sort of index already: primary keys (which are normally sequentially increasing integers called <code>id</code> or similar.)</p>\n<p>Unique and primary keys create indexes by default and you don&#39;t need to do anything else to get them. They do this because everytime you insert into a unique key it needs to go check if it already exists so it can enforce uniqueness, making it necessary to have an index.</p>\n<p>Keep in mind you can also have uniqueness as a constraint across multiple columns. Imagine you stored address, city, and state as three columns. Multiple people could live on <code>1000 4th Street</code> across Seattle, San Francisco, Minneapolis, and Savannah, but there can only be one <code>1000 4th Ave, Seattle, WA</code>. Thereforce a unique constraint across multiple columns could be really useful. You&#39;d do that with something like</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">TABLE</span> american_addresses (\n    id <span class=\"hljs-type\">INTEGER</span> <span class=\"hljs-keyword\">PRIMARY</span> KEY GENERATED ALWAYS <span class=\"hljs-keyword\">AS</span> <span class=\"hljs-keyword\">IDENTITY</span>,\n    street_address <span class=\"hljs-type\">int</span> <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span>,\n    city <span class=\"hljs-type\">VARCHAR</span>(<span class=\"hljs-number\">255</span>) <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span>,\n    state <span class=\"hljs-type\">VARCHAR</span>(<span class=\"hljs-number\">255</span>) <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span>,\n    <span class=\"hljs-keyword\">UNIQUE</span> (street_address, city, state)\n);\n</code></pre>\n","slug":"indexes","title":"Indexes","section":"Query Performance","icon":"fire","filePath":"/home/runner/work/complete-intro-to-sql/complete-intro-to-sql/lessons/09-query-performance/B-indexes.md","nextSlug":"/lessons/query-performance/create-an-index","prevSlug":"/lessons/query-performance/explain"}},"__N_SSG":true}