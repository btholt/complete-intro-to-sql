{"pageProps":{"post":{"attributes":{},"html":"<p>Let&#39;s have a chat about query performance.</p>\n<p>How different do you think these queries are?</p>\n<pre><code class=\"language-sql\">SELECT * FROM movies WHERE name=&#39;Tron Legacy&#39;;\nSELECT * FROM movies WHERE id=21103;\n</code></pre>\n<p>Turns out, from a performance perspective, they are <em>wildly</em> different. The second query is <em>623×</em> times faster on my computer. Why? Let&#39;s find out!</p>\n<pre><code class=\"language-sql\">EXPLAIN ANALYZE SELECT * FROM movies WHERE name=&#39;Tron Legacy&#39;;\nEXPLAIN ANALYZE SELECT * FROM movies WHERE id=21103;\n</code></pre>\n<p>This will show you some output on the performance profile of our query.</p>\n<p>A couple key things I want to draw to your attention:</p>\n<ul>\n<li><code>cost=0.00..4988.77</code> vs <code>cost=0.42..8.44</code>. This cost is arbitrary unit meant to be used comparatively, like in this case.</li>\n<li>The first number is the startup cost. Generally for SELECTs like this it&#39;s near zero but if you&#39;re doing a sort of some variety you can incur startup cost.</li>\n<li>The second number is the total cost of the query. You can see here that they are <em>very</em> different.</li>\n</ul>\n<p>Here&#39;s a quote on how they measure the cost <a href=\"https://scalegrid.io/blog/postgres-explain-cost/\">from a great article</a></p>\n<blockquote>\n<p>The cost units are anchored (by default) to a single sequential page read costing 1.0 units (seq_page_cost). Each row processed adds 0.01 (cpu_tuple_cost), and each non-sequential page read adds 4.0 (random_page_cost). There are many more constants like this, all of which are configurable. That last one is a particularly common candidate, at least on modern hardware. We’ll look into that more in a bit.</p>\n</blockquote>\n<ul>\n<li><code>Seq Scan</code> vs <code>Index Scan</code> is what&#39;s actually making a difference here.</li>\n<li><code>Seq Scan</code> means it read <em>every row in the table</em> to get your ansewr. Yeah, not good. You can see it read <code>Rows Removed by Filter: 175720</code> to get our one answer. Wild!</li>\n<li><code>Index Scan</code> means it had access to an index to find the correct row. Remember <a href=\"https://btholt.github.io/complete-intro-to-computer-science/binary-search-tree\">trees from data structures and algorithms</a>? This is where they are used!! We can tell PostgreSQL in advance &quot;hey, this is going to get queried in the future and I want to it to be fast, please build a tree so that you can find it faster. We&#39;ll talk about making new indexes in the next section.</li>\n</ul>\n<h2 id=\"more-complicated-queries\">More complicated queries.</h2>\n<p>Let&#39;s grab one of our previous lesson&#39;s answers.</p>\n<pre><code class=\"language-sql\">EXPLAIN ANALYZE SELECT\n  m.name, COUNT(c.id) AS count\nFROM\n  movies m\n\nINNER JOIN\n  movie_keywords mk\nON\n  mk.movie_id = m.id\n\nINNER JOIN\n  categories c\nON\n  mk.category_id = c.id\n\nGROUP BY\n  m.id, m.name\n\nORDER BY\n  count DESC\n\nLIMIT 10;\n</code></pre>\n<p>Here you&#39;ll see a variety new bits of nested information. Let&#39;s analyze (lol)</p>\n<ul>\n<li>Startup cost is almost everything here. That means it&#39;s taking a long time to get all the rows in a place to be queried. Once all the rows are in assembled and joined together the actual execution is trivial.</li>\n<li>We aggregated <code>rows=46516</code> in the second step into our final answer</li>\n<li>Our merge join was actually pretty fast because we did it on IDs that had indexes on them.</li>\n<li>The aggregation and the ordering took the most time here. That&#39;s the take away.</li>\n</ul>\n","slug":"explain","title":"Explain","section":"Query Performance","icon":"fire","filePath":"/home/runner/work/complete-intro-to-sql/complete-intro-to-sql/lessons/09-query-performance/A-explain.md","nextSlug":"/lessons/query-performance/indexes","prevSlug":"/lessons/the-movie-database/pgadmin"}},"__N_SSG":true}