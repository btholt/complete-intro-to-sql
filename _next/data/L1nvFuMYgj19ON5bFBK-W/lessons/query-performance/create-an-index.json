{"pageProps":{"post":{"attributes":{},"html":"<p>Okay, so we&#39;ve identified that we frequently query movies by exact names and this is a query we want to support. It&#39;s a big table (175721 rows) and therefore a sequential scan on this is <em>pricy</em>. So how we go about doing that?</p>\n<pre><code class=\"language-sql\">EXPLAIN ANALYZE SELECT * FROM movies WHERE name=&#39;Tron Legacy&#39;;\n\nCREATE INDEX idx_name ON movies(name);\n\nEXPLAIN ANALYZE SELECT * FROM movies WHERE name=&#39;Tron Legacy&#39;;\n</code></pre>\n<p>Check out the difference there. On my machine I&#39;m seeing a difference between a cost of <code>4929.51</code> and <code>12.30</code> for the total cost. <em>Wild</em>, right?</p>\n<p>Do note I&#39;m also seeing a difference in the startup cost. A sequential scan has a startup cost <code>0.00</code> or at least very, very low and the cost of the index for me is <code>4.44</code>. This is why sometimes using an index isn&#39;t worth it for the planner: using an index isn&#39;t <em>free</em>. You incur overhead to use it. Think of it doing something like memoization in your code. You don&#39;t memoize everything because frequently it buys you nothing with lots of additional code and overhead. Similar idea here.</p>\n<h2 id=\"b-tree-versus-others\">B-tree versus others</h2>\n<p>When you say <code>CREATE INDEX</code> you are implicitly saying you want a b-tree index. A <a href=\"https://en.wikipedia.org/wiki/B-tree\">b-tree</a> is a data structure that is specifically easy to search.</p>\n<p>I teach a lesson on <a href=\"https://frontendmasters.com/courses/computer-science-v2/\">Frontend Masters</a> on how to do AVL trees which are a simplification of b-trees if you want to get into how a self-balancing tree works.</p>\n<p>B-trees are compact, fairly simple data structures that are suited to general indexes. However there are a few more to be aware of. We&#39;re about to talk about GIN indexes next so let&#39;s cover the ones first we&#39;re not going to be talking about.</p>\n<ul>\n<li>Hash - Useful for when you&#39;re doing strict equality checks and need it fast and in memory. Can&#39;t handle anything other than <code>=</code> checks.</li>\n<li>GiST - Can also be used for full text search but ends up with false positives sometimes so GIN is frequently preferred.</li>\n<li>SP-GiST - Another form of GiST. Both GiST and SP-GiST offer a variety of different searchable structures and are much more special-use-case. I&#39;ve never had to use either. SP-GiST is most useful for clustering types of search and &quot;nearest neighbor&quot; sorts of things.</li>\n<li>BRIN - BRIN is most useful for extremely large tables where maintaing a b-tree isn&#39;t feasible. BRIN is smaller and more compact and therefore makes larger table indexing more feasible.</li>\n</ul>\n<p><a href=\"https://www.postgresql.org/docs/current/indexes-types.html\">This page from the docs about index types</a> is helpful to glance at.</p>\n","slug":"create-an-index","title":"Create an Index","section":"Query Performance","icon":"fire","filePath":"/home/runner/work/complete-intro-to-sql/complete-intro-to-sql/lessons/09-query-performance/C-create-an-index.md","nextSlug":"/lessons/query-performance/gin","prevSlug":"/lessons/query-performance/indexes"}},"__N_SSG":true}